// generated by Fast Light User Interface Designer (fluid) version 1.0304
#pragma once

#include "ImageGUI.h"

#include <iostream>

#include <FL\Fl_File_Chooser.H>

#include <FL\Fl_Native_File_Chooser.H>


using namespace std;

// static Method: InputCallback
// Definition: Assigned to each of the buttons as their callback function
// Param 1: Fl_Widget* Widg; the activated widget
// Param 2: void* data; concrete ImageGUI class
static void InputCallBack(Fl_Widget* Widg, void* data)
{
	ImageGUI *object = (ImageGUI*)data;
	object->CallBack(Widg);
}

// Method: Constructor
// Definition: Create this class
// Param 1: shared_ptr<IView> pView; the view using this gui
ImageGUI::ImageGUI(shared_ptr<IView> pView)
{
	mView = pView;

	window = make_shared<Fl_Double_Window>(600, 600, "Penguin Image Viewer");

	window->box(FL_UP_BOX);
	window->user_data((void*)(this));

	// Fl_Box* ImageBox
	ImageBox = make_shared<Fl_Box>(10, 150, 400, 400, "");
	ImageBox->box(FL_BORDER_FRAME);
	//ImageBox->color(FL_GRAY0);

	// Fl_Button* Load
	Load = make_shared<Fl_Button>(35, 10, 50, 25, "Load");
	Load->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* previousImage
	previousImage = make_shared<Fl_Button>(10, 80, 50, 25, "<");
	previousImage->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* nextImage
	nextImage = make_shared<Fl_Button>(60, 80, 50, 25, ">");
	nextImage->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* Save
	Save = make_shared<Fl_Button>(35, 40, 50, 25, "Save");
	Save->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* RotLeft
	RotLeft = make_shared<Fl_Button>(316, 10, 64, 20, "RotLeft");
	RotLeft->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* RotRight
	RotRight = make_shared<Fl_Button>(316, 40, 64, 20, "RotRight");
	RotRight->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* FlipH
	FlipH = make_shared<Fl_Button>(110, 10, 64, 20, "FlipH");
	FlipH->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* FlipV
	FlipV = make_shared<Fl_Button>(110, 40, 64, 20, "FlipV");
	FlipV->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* ScaleUp
	ScaleUp = make_shared<Fl_Button>(415, 10, 75, 20, "ScaleUp");
	ScaleUp->callback((Fl_Callback*)InputCallBack, this);

	// Fl_Button* ScaleDown
	ScaleDown = make_shared<Fl_Button>(415, 40, 75, 20, "ScaleDown");
	ScaleDown->callback((Fl_Callback*)InputCallBack, this);

	Scaler = make_shared<Fl_Value_Input>(500, 25, 40, 20, "");

	//ScaleW = make_shared<Fl_Value_Input>(540, 40, 40, 20, "Vector:");

	Rotater = make_shared<Fl_Value_Input>(260, 25, 40, 20, "");

	//RotR = make_shared<Fl_Value_Input>(240, 40, 40, 20, "Degree:");


	window->end();
	window->show();
}

ImageGUI::~ImageGUI()
{
	window.reset();
	//mView.reset();
}

// Method: CallBack
// Definition: Called when a button widget has been clicked
// Param 1: Fl_Widget* Widg; the widget which has been clicked
void ImageGUI::CallBack(Fl_Widget* Widg)
{
	int button;
	vector<string> imageFiles;
	double number = 0;
	string saveFilePath;

	if (Widg->label() == "Load")
	{
		//Handle click through view
		cout << "Load callback" << endl;
		button = 1;

		// GET user input to specify path to image file:
		imageFiles = GetInput("Please Choose an Image to Display... ");
	}
	else if (Widg->label() == "<")
	{
		//Hanlde click through view
		cout << "Previous callback" << endl;
		button = 2;
	}
	else if (Widg->label() == ">")
	{
		//Hanlde click through view
		cout << "Next callback" << endl;
		button = 3;
	}
	else if (Widg->label() == "Save")
	{
		//Hanlde click through view
		cout << "Save callback" << endl;
		button = 4;
		saveFilePath = GetSavePath();
	}
	else if (Widg->label() == "RotLeft")
	{
		//Hanlde click through view
		cout << "RotLeft callback" << endl;
		number = Rotater->value();
		button = 5;
	}
	else if (Widg->label() == "RotRight")
	{
		//Hanlde click through view
		cout << "RotRight callback" << endl;
		number = Rotater->value();
		button = 6;
	}
	else if (Widg->label() == "FlipH")
	{
		//Hanlde click through view
		cout << "FlipH callback" << endl;
		button = 7;
	}
	else if (Widg->label() == "FlipV")
	{
		//Hanlde click through view
		cout << "FlipV callback" << endl;
		button = 8;
	}
	else if (Widg->label() == "ScaleUp")
	{
		//Hanlde click through view
		cout << "ScaleUp callback" << endl;
		button = 9;
		number = Scaler->value();
	}
	else if (Widg->label() == "ScaleDown")
	{
		//Hanlde click through view
		cout << "ScaleDown callback" << endl;
		button = 10;
		number = Scaler->value();
	}

	mView->GetClicker()->HandleClick(button, imageFiles, number, saveFilePath);
}

// Method: GetInput
// Definition: Upon clicking Load, execute this function
// Param 1: string
// Return: vector<string>; File locations of images to load
vector<string> ImageGUI::GetInput(string prompt)
{
	// CREATE a vector<string> to hold the return value, call it rtnVal:
	// MODIFIED: Instantiate the vector<string>
	vector<string> rtnVal = vector<string>();

	// INSTANTIATE file chooser window, call it fileInput:
	Fl_File_Chooser fileInput = Fl_File_Chooser(".", "*", Fl_File_Chooser::MULTI, prompt.c_str());

	// SHOW fileInput:
	fileInput.show();

	// WAIT for user input:
	while (fileInput.shown())
	{
		Fl::wait();
	}

	// RETURN the entered text as a single string:
	if ((NULL != fileInput.value()) && (0 < fileInput.count()))
	{
		// ITERATE through filenames collected:
		for (int i = 0; i < fileInput.count(); i++)
		{
			// Convert each filename to a string and push onto rtnVal:
			string rtn;
			rtn.assign(fileInput.value(i + 1));
			rtnVal.push_back(rtn);
		}
	}

	return rtnVal;
}

// Method: GetSavePath
// Definition: Upon clicking save, execute this function, with users input returns a save file location
// Return: string
string ImageGUI::GetSavePath()
{
	// INSTANTIATE file chooser window, call it fileInput:
	Fl_Native_File_Chooser fileInput = Fl_Native_File_Chooser(4);

	cout << fileInput.type();

	fileInput.filter("*.png");
	fileInput.filter_value(0);

	// SHOW fileInput:
	fileInput.show();

	cout << fileInput.filename() << endl;

	string filterToAdd;

	switch (fileInput.filter_value())
	{
		case 0:
			filterToAdd = ".png";
			break;
		default:
			filterToAdd = ".png";
			break;
	}

	return fileInput.filename() + filterToAdd;
}

// Method: DataModified
// Definition: Called when data has been changed
// Param 1: shared_ptr<IEventArgs>
void ImageGUI::DataModified(shared_ptr<IEventArgs> data)
{
	try
	{
		shared_ptr<IImage> imageWrapper = dynamic_pointer_cast<IImage>(data->GetData());

		if (imageWrapper == nullptr)
		{
			throw(false);
		}

		// SET boxWidth and boxHeight to image dimensions:
		// MODIFIED: Use functions found in IImage.h
		// imageWrapper->GetFipImage() for access to fipImage
		boxWidth = (imageWrapper->GetFipImage()->getWidth());
		boxHeight = (imageWrapper->GetFipImage()->getHeight());

		if (boxWidth > maxBoxWidth)
		{
			boxWidth = 900;

			imageWrapper->GetFipImage()->rescale(900, 900, FILTER_BOX);
		}
		if (boxHeight > maxBoxHeight)
		{
			boxHeight = 900;

			imageWrapper->GetFipImage()->rescale(900, 900, FILTER_BOX);
		}

		// RESIZE window:
		Resize();

		// INSERT image into imageBox:
		// MODIFIED: Use functions found in IImage.h
		// imageWrapper->GetFipImage() for access to fipImage
		ImageBox->image(new Fl_RGB_Image(imageWrapper->GetFipImage()->accessPixels(), imageWrapper->GetFipImage()->getWidth(), imageWrapper->GetFipImage()->getHeight(),
			imageWrapper->numberOfChannels(), 0));

		// REFRESH:
		ImageBox->hide();
		ImageBox->show();
	}
	catch (bool b)
	{
		cout << "No data selected;" << endl;
		cout << "Please use the 'Load' button to load an item." << endl;
	}


}

// Method: Resize
// Definition: Resize the window and the image box which stores the image
void ImageGUI::Resize()
{
	// RESIZE imageBox to fit image:
	ImageBox->size(boxWidth, boxHeight);

	// RESIZE topWindow to fit image:
	if (ImageBox->w() > window->w())
	{
		window->size(boxWidth + (rightPadding * 2), window->h());
	}
	else
	{
		window->size(600, boxHeight + lowerPadding + (upperPadding * 4));
	}

	if (ImageBox->h() > window->h())
	{
		window->size(window->w(), boxHeight + upperPadding + lowerPadding);
	}
	else
	{
		window->size(600, boxHeight + lowerPadding + (upperPadding * 4));
	}

	// MOVE loadButton to bottom of topWindow:
	/*int loadPosnX = (int)((boxWidth + leftPadding + rightPadding - loadWidth)*0.5);
	int loadPosnY = boxHeight + lowerPadding - loadHeight - upperPadding;
	Load->position(loadPosnX, loadPosnY);*/

	// MOVE fwdsButton accordingly:
	/*int fwdsPosnX = loadPosnX + loadWidth + loadWidth;
	fwdsButton->position(fwdsPosnX, loadPosnY);*/

	// MOVE bwdsButton accordingly:
	/*int bwdsPosnX = loadPosnX - loadWidth - loadWidth;
	bwdsButton->position(bwdsPosnX, loadPosnY);*/

}